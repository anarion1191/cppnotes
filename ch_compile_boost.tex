\chapter{Building the Boost Library}

In order to build the Boost library, the tool \textbf{b2} should be used. Assuming \textbf{clang++} is in the path, in order to build Boost using Clang++ and libc++:

\begin{lstlisting}[language=bash]
    ./b2 toolset=clang cxxflags="-stdlib=libc++ -std=c++14" linkflags="-stdlib=libc++" -j 8
\end{lstlisting}

At the moment (Boost version 1.66.0), compilation cannot be done with the \lstinline[language=bash]|-std=c++17| flag, because the \lstinline|auto_ptr| class has been removed but parts of Boost are still using it. \lstinline|auto_ptr| had been deprecated since C++11 and finally removed in C++17.

Compiling boost took the following time in the first round:
real	116m2.628s
user	474m24.432s
sys	90m33.540s

In total, there were 54 failed targets due to missing pyconfig.h header, which is due to not having python3.5-dev installed. After installing, I still had to execute the following:
\begin{lstlisting}[language=bash]
    export CPLUS_INCLUDE_PATH=/usr/include/python3.5
\end{lstlisting}

After installing the needed package, and re-running the build script, it took the following times:
real	7m17.312s
user	29m13.704s
sys	5m40.344s

In order to install the built libraries, as root and after making sure CXX is set to clang++, I executed the following:
\begin{lstlisting}[language=bash]
    ./b2 install toolset=clang cxxflags="-std=c++14 -stdlib=libc++" linkflags="-stdlib=libc++" --prefix=/usr/local
\end{lstlisting}

Also, last but not least, when building a project that uses Boost::Log, I encountered linker errors that I could not exactly figure out why they are happening, as it seems like I do have the shared object files of the log library. However, after modifying boost/config/user.hpp and adding the following line, then rebuilding boost, I seem to be able to correctly link:
\begin{lstlisting}[language=bash]
    #define BOOST_LOG_DYN_LINK
\end{lstlisting}

Update: later on, I was trying to see if I can link Boost libraries statically, as this reduced the need to deploy the built Boost libraries along with my program, if there has been library changes. To do this, I re-built Boost using the following:
\begin{lstlisting}[language=bash]
    ./b2 toolset=clang link=static cxxflags="-stdlib=libc++ -std=c++14" linkflags="-stdlib=libc++" -j 8
\end{lstlisting}

Then, in order to force a static link of Boost in my project, I used the following CMake file:
\begin{lstlisting}[language=CMake]
set("${TARGET_NAME}" PROPERTY CXX_STANDARD 14)

add_executable("${TARGET_NAME}" "src/main.cpp")

target_include_directories("${TARGET_NAME}" PUBLIC "include" ${Boost_INCLUDE_DIRS})
target_compile_options("${TARGET_NAME}" PUBLIC "-stdlib=libc++")

target_link_libraries("${TARGET_NAME}" PUBLIC -nodefaultlibs -lc++ -lc++abi -lc -lm -lgcc_s -lgcc)

set(Boost_USE_STATIC_LIBS ON)
find_package(Boost 1.66.0 EXACT REQUIRED COMPONENTS thread system log_setup log filesystem)
message(${Boost_LIBRARIES})
target_link_libraries("${TARGET_NAME}" PUBLIC ${Boost_LIBRARIES})

target_link_libraries("${TARGET_NAME}" PUBLIC -lpthread)
\end{lstlisting}

At first, there were some linker errors with references to code in the filesystem library. It turns out, the log library depends on filesystem and therefore, the filesystem library must be linked after the log library.
